package org.apache.giraph.tools.graphanalytics.relextractor;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;

import org.apache.giraph.comm.messages.VertexMessageStore;
import org.apache.giraph.edge.Edge;
import org.apache.giraph.graph.Vertex;
import org.apache.giraph.plan.EdgeDirection;
import org.apache.giraph.plan.QueryNode;
import org.apache.hadoop.io.IntWritable;

public class RelExtractionVertex extends Vertex<IntWritable, IntWritable, IntWritable, PackagedNeighborInfo> {

	private ArrayList<Integer> inNbrArray;
	private ArrayList<Integer> inNbrLabelArray;
	private ArrayList<Integer> inWeightArray;
	private ArrayList<Integer> inEdgeLabelArray;
	
	private HashMap<Integer, Integer> outNbrLabel;
	
	@Override
	public void compute(Iterable<PackagedNeighborInfo> messages) throws IOException {
		if(getSuperstep() == 0) {
			PackagedNeighborInfo msg = new PackagedNeighborInfo();
			msg.setVid(this.getId().get());
			msg.setVlabel(this.getValue().get());
			for(Edge<IntWritable, IntWritable> edge : this.getEdges()) {
				msg.setElabel(edge.getValue().get());
				msg.setWeight(new IntWritable(1));
				sendMessage(edge.getTargetVertexId(), msg);
			}
		}
		else if(getSuperstep() == 1){
			inNbrArray = new ArrayList<Integer>();
			inNbrLabelArray = new ArrayList<Integer>();
			inWeightArray = new ArrayList<Integer>();
			inEdgeLabelArray = new ArrayList<Integer>();
			PackagedNeighborInfo newMsg = new PackagedNeighborInfo();
			newMsg.setVid(this.getId().get());
			newMsg.setVlabel(this.getValue().get());
			for(PackagedNeighborInfo msg : messages) {
				inNbrArray.add(msg.getVid());
				inNbrLabelArray.add(msg.getVlabel());
				inEdgeLabelArray.add(msg.getElabel());
				inWeightArray.add(msg.getWeight().get());
				sendMessage(new IntWritable(msg.getVid()), newMsg); //send back to the source for reporting the label of vertex.
			}
		}
		else if(getSuperstep() == 2) {
			outNbrLabel = new HashMap<Integer, Integer> ();
			for(PackagedNeighborInfo msg : messages) {
					outNbrLabel.put(msg.getElabel(), msg.getVlabel());
			}
		}
		if(getSuperstep() > 1) {
			ArrayList<QueryNode> queries = getQueries();
			if(queries.isEmpty())
				return ;
			if(queries.get(0).isLeafNode()) {
				processLeafQuery(queries);
			}
			else {
				processMiddleQuery(messages, queries);	
			}
		}
	}
		
	public void processLeafQuery(ArrayList<QueryNode> queries) {
		//process leaf node with no incoming messages
		for(QueryNode qn : queries) {
			if(qn.getNodeLabel() == this.getValue().get()) { //same label
				int qid = qn.getNodeId();
				
				ArrayList<Integer> sid = new ArrayList<Integer>();
				ArrayList<Integer> sweight = new ArrayList<Integer>();
				ArrayList<Integer> tid = new ArrayList<Integer>();		
				ArrayList<Integer> tweight = new ArrayList<Integer>();
				
				/* matching process */
				getMatchedEdge(qn.getLeftLabel(), qn.getLeftEdgeDirection(), qn.getLeftEdgeLabel(), sid, sweight);
				getMatchedEdge(qn.getRightLabel(), qn.getRightEdgeDirection(), qn.getRightEdgeLabel(), tid, tweight);
				
				if(qn.getLevel() == 0) {
					int count = sid.size() * tid.size();
					System.out.println("Total size with duplicated: "+count);
					this.voteToHalt();
				}
				else {
					//TODO: send new queries with weights;
				}
			}
		}
	}
	
	private void getMatchedEdge(int vlabel, EdgeDirection edgeDirection,
			int elabel, ArrayList<Integer> sid,
			ArrayList<Integer> sweight) {
		if(edgeDirection == EdgeDirection.INCOMING || edgeDirection == EdgeDirection.BOTH) {
			for(int idx = 0; idx < inNbrArray.size(); ++idx) {
				if(inNbrLabelArray.get(idx) == vlabel && inEdgeLabelArray.get(idx) == elabel) {
					sid.add(inNbrArray.get(idx));
					sweight.add(inWeightArray.get(idx));
				}
			}
		}

		if(edgeDirection == EdgeDirection.OUTGOING || edgeDirection == EdgeDirection.BOTH) {
			for(Edge<IntWritable, IntWritable> edge : this.getEdges()) {
				if(outNbrLabel.get(edge.getTargetVertexId().get()) == vlabel && edge.getValue().get() == elabel) {
					sid.add(edge.getTargetVertexId().get());
					sweight.add(edge.getValue().get());
				}
			}
		}
	}

	/**
	 * The compatibility of VMS and messages should be addressed.
	 * 
	 * @param vms
	 * @param queries
	 */
	public void processMiddleQuery(Iterable<PackagedNeighborInfo> messages, ArrayList<QueryNode> queries) {
		VertexMessageStore<IntWritable> vms = new VertexMessageStore<IntWritable>();
		for(PackagedNeighborInfo msg : messages) {
			vms.addMessage(msg.getVid(), msg.getElabel(), msg.getWeight());
		}
		for(QueryNode qn : queries) {
			if(qn.getNodeLabel() == this.getValue().get()) { //same label
				HashMap<Integer, IntWritable> leftMessages = vms.getMessageByQuery(qn.getLeftQueryId());
				HashMap<Integer, IntWritable> rightMessages = vms.getMessageByQuery(qn.getRightQueryId());
				//TODO: combine message here and send them 
			}
		}
	}

}
