package org.apache.giraph.plan;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;

import org.apache.giraph.conf.GiraphConstants;
import org.apache.giraph.conf.ImmutableClassesGiraphConfiguration;

public class QueryPlan {
	
	private ArrayList<QueryNode> queryNodes;
	
	/* auxiliary data structure. */
	private HashMap<Integer, QueryNode> qid2Parent;
	private HashMap<Integer, ArrayList<QueryNode>> queriesByLevel;
	private HashMap<Integer, QueryNode> id2Query;
	private int maxLevel;
	
	private ImmutableClassesGiraphConfiguration conf;
	
	public QueryPlan() { 
		queryNodes = new ArrayList<QueryNode> ();
	}
	
	public void createMinQuery(int level, ArrayList<RawQueryNode> qnList, int startIdx, int endIdx, boolean isLeftQuery) {
		generateTreePlan(level, qnList, startIdx, endIdx, isLeftQuery);
	}
	
	public void setConf(ImmutableClassesGiraphConfiguration conf) {
		this.conf = conf;
	}
	
	/**
	 * generate the plan by Depth First Search.
	 * @param level
	 * @param qnList
	 * @param startIdx
	 * @param endIdx
	 * @param isLeftQuery
	 * @return
	 */
	private int generateTreePlan(int level, ArrayList<RawQueryNode> qnList, int startIdx, int endIdx, boolean isLeftQuery) {
		int midIdx = (endIdx + startIdx + 1) >> 1; //Ensure the midIdx is the bigger one when two candidates are possible. 
  	  	int vLabel = qnList.get(midIdx).getVlabel();
  	  	QueryNode qn = new QueryNode();
		
  	  	if(endIdx - startIdx < 3) {
  	  		int leftLabel = (startIdx == midIdx) ? -1 : qnList.get(startIdx).getVlabel();
  	  		int rightLabel = (endIdx == midIdx) ? -1 : qnList.get(endIdx).getVlabel();
  	  		EdgeDirection leftEd = (startIdx == midIdx) ? EdgeDirection.UNSET : qnList.get(startIdx).getEdgeDirection();
  	  		EdgeDirection rightEd = (endIdx == midIdx) ? EdgeDirection.UNSET : qnList.get(midIdx).getEdgeDirection();// Assume the input query is a line.
  	  		if(leftEd == EdgeDirection.OUTGOING) {
  	  			leftEd = EdgeDirection.INCOMING;
  	  		}
  	  		else if(leftEd == EdgeDirection.INCOMING) {
  	  			leftEd = EdgeDirection.OUTGOING;
  	  		}
  	  		int leftEdgeLabel = (startIdx == midIdx) ? -1 : qnList.get(startIdx).getElabel();
  	  		int rightEdgeLabel = (endIdx == midIdx) ? -1 : qnList.get(midIdx).getElabel(); // Assume the input query is a line.
		  
  	  		qn.setLeafNode();
  	  		qn.setNodeLabel(vLabel);
  	  		qn.setLeftLabel(leftLabel);
  	  		qn.setRightLabel(rightLabel);
  	  		qn.setLeftEdgeDirection(leftEd);
  	  		qn.setLeftEdgeLabel(leftEdgeLabel);
  	  		qn.setRightEdgeDirection(rightEd);
  	  		qn.setRightEdgeLabel(rightEdgeLabel);
  	  		qn.setLevel(level);
  	  		qn.setLeftQuery(isLeftQuery);
		  
  	  		this.add(qn);
  	  		return qn.getNodeId();
  	  	}
	  
  	  	int leftQueryId = generateTreePlan(level + 1, qnList, startIdx, midIdx, true);
  	  	int rightQueryId = generateTreePlan(level + 1, qnList, midIdx, endIdx, false);
  	  	qn.setNodeLabel(vLabel);
  	  	qn.setLeftQueryId(leftQueryId);
  	  	qn.setRightQueryId(rightQueryId);
  	  	qn.setLevel(level);
  	  	qn.setLeftQuery(isLeftQuery);
	 
  	  	this.add(qn); // determine the ID in the add() method.
	  
  	  	return qn.getNodeId();
	}

	/**
	 * must be called before querying the plan.
	 */
	public void initialize() {		
		qid2Parent = new HashMap<Integer, QueryNode>();
		queriesByLevel = new HashMap<Integer, ArrayList<QueryNode>> ();
		id2Query = new HashMap<Integer, QueryNode>();
		maxLevel = -1;

		//merge the same query.
		if(GiraphConstants.GRAPHOLAP_PATH_EVALUATION_QUERY_SHARING.get(conf)) {
			queryNodes = mergeSameQuery(queryNodes);
		}
		
		for(QueryNode qn : queryNodes) {
			if(qn.isLeafNode() == false) {
				qid2Parent.put(qn.getLeftQueryId(), qn);
				qid2Parent.put(qn.getRightQueryId(), qn);
			}
			id2Query.put(qn.getNodeId(), qn);
			maxLevel = (maxLevel > qn.getLevel() ? maxLevel : qn.getLevel());
			ArrayList<QueryNode> qList = queriesByLevel.get(qn.getLevel());
			if(qList == null)
				qList = new ArrayList<QueryNode>();
			qList.add(qn);
			queriesByLevel.put(qn.getLevel(), qList);
		}
	}
	
	/**
	 * using find and union data structure.
	 * @param queryNodes
	 * @return
	 */
	private ArrayList<QueryNode> mergeSameQuery(ArrayList<QueryNode> queryNodes) {
		ArrayList<QueryNode> res = new ArrayList<QueryNode>();
		Collections.sort(queryNodes, new Comparator<QueryNode> () {
			@Override
			public int compare(QueryNode first, QueryNode second) {
				return second.getLevel() - first.getLevel();
			}
		});
		
		int leafLevel = queryNodes.get(0).getLevel();
		int curLevel = queryNodes.get(0).getLevel();
		boolean isNewLevel = false;
		DisjointSets dsets = new DisjointSets(queryNodes.size());
		int startIdx = 0;
		for(int idx = 0; idx < queryNodes.size(); idx++) {
			QueryNode curQN = queryNodes.get(idx);
			isNewLevel = (curLevel != curQN.getLevel());
			
			if(curQN.getLevel() == leafLevel) {
				/* leaf node processing */
				QueryNode tmpQN = null;
				for(QueryNode qn : res) {
					if(qn.equals(curQN)) {
						tmpQN = qn;
						break;
					}
				}
				if(tmpQN == null) {
					res.add(curQN);
				}
				else {
					dsets.union(dsets.find(curQN.getNodeId()), dsets.find(tmpQN.getNodeId())); //merge the same query nodes;
					tmpQN.setNodeId(dsets.find(tmpQN.getNodeId()));
				}
			}
			else {
				QueryNode newQn = new QueryNode();
				newQn.copy(curQN);
				newQn.setLeftQueryId(dsets.find(curQN.getLeftQueryId()));
				newQn.setRightQueryId(dsets.find(curQN.getRightQueryId()));
				newQn.setNodeId(dsets.find(newQn.getNodeId()));
				if(isNewLevel) {
					startIdx = res.size();
					res.add(newQn);
					isNewLevel = false;
					curLevel = curQN.getLevel();
				}
				else {
					QueryNode tmpQN = null;
					for(int idx1 = startIdx; idx1 < res.size(); idx1++) {
						if(res.get(idx1).equals(newQn)) {
							tmpQN = res.get(idx1);
							break;
						}
					}
					if(tmpQN == null) {
						res.add(newQn);
					}
					else {
						dsets.union(dsets.find(newQn.getNodeId()), dsets.find(tmpQN.getNodeId()));
						tmpQN.setNodeId(dsets.find(tmpQN.getNodeId()));
					}
				}
			}
		}
		return res;
	}

	public void add(QueryNode qn) {
		qn.setNodeId(queryNodes.size());
		queryNodes.add(qn);
	}

	public void write(DataOutputStream out) throws IOException {
		int size = queryNodes.size();
		out.writeInt(size);
		for(QueryNode qn : queryNodes) {
			qn.write(out);
		}
	}
	
	public void readFields(DataInputStream in) throws IOException {
		int size = in.readInt();
		if(queryNodes == null) {
			queryNodes = new ArrayList<QueryNode> ();
		}
		else {
			queryNodes.clear();
		}
		for(int i = 0; i < size; i++) {
			QueryNode qn = new QueryNode();
			qn.readFields(in);
			queryNodes.add(qn);
		}
		this.initialize();
	}
	
	public String toString() {
		StringBuffer res = new StringBuffer();
		res.append("\nQuery plan size: "+ queryNodes.size());
		for(QueryNode qn : queryNodes) {
			res.append("\n\t"+qn.toString());
		}
		return res.toString();
	}

	/**
	 * bottom-up fashion: the larger level is, the lower position is.
	 * @param superstep
	 * @return
	 */
	public ArrayList<QueryNode> getQueryByLevel(long superstep) {
		int curLevel = (int)(maxLevel - superstep);
		if(curLevel < 0 || curLevel > maxLevel)
			return null;
		return queriesByLevel.get(curLevel);
	}
	
	public QueryNode getQueryNodeByChild(int qid) {
		return this.qid2Parent.get(qid);
	}
	
	public boolean isLeftQuery(int qid) {
		return id2Query.get(qid).isLeftQuery();
	}
	
}
